import os
import sys
import argparse

import pulp
import numpy as np
import re

import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from collections import defaultdict

class FileWriter():
    def __init__(self,pargs):
        self.th = pargs.th
        self.op = pargs.op
        self.input_file = pargs.input_file
        self.arch = pargs.arch
        self.df = pd.read_csv(self.input_file, sep='\t')

    def parse_perfconfigs(self, perfconfig_str):
        perfconfig_str = perfconfig_str.replace('v2:','')
        config_values = perfconfig_str.split(',')
        total_values = len(config_values)
        converted_values = []
        for idx, value in enumerate(config_values):
            if idx > total_values - 3 and total_values == 9:
                if value == '1':
                    converted_values.append('true')
                else:
                    converted_values.append('false')
            else:
                converted_values.append(value)
        
        formated_perfconfig = ','.join(converted_values)
        return formated_perfconfig

    def replace_section(self, file_path, begin_marker, end_marker, new_content):
        with open(file_path,'r') as file:
            content = file.read()

        pattern = re.compile(f'{begin_marker}.*?{end_marker}', re.DOTALL)
        replacment = f'{begin_marker}\n{new_content}\n{end_marker}'
        content = pattern.sub(replacment, content)

        with open(file_path,'w') as file:
            file.write(content)

    def get_instruction_type(self, arch, datatype):
        if arch.startswith("gfx9"):
            return "XDL"
        elif arch.startswith("gfx1") and datatype != "f32":
            return "Wmma"
        else:
            return "NonAccel"

    def init_inc_file(self, file_path):
        instruction_types_to_datatypes ={
            "NonAccel" : ["f32"],
            "XDL" : ["f32", "f16", "i8"],
            "Wmma" : ["f16", "i8"]
        }
        markers = [
            "// BEGIN_GEMM",
            "// END_GEMM",
            "// BEGIN_CONV",
            "// END_CONV",
        ]

        with open(file_path, 'w') as file:
            file.write("// THIS IS AN AUTOGENERATED FILE.\n")
            file.write("// DO NOT EDIT THIS FILE DIRECTLY!\n\n")
            for instrction_type, datatypes in instruction_types_to_datatypes.items():
                file.write(f"#ifdef {instrction_type}_DEFINITIONS_GEN\n\n")
                for datatype in datatypes:   
                    for marker in markers:
                        file.write(f"{marker}_{instrction_type}_{datatype}_DEFS\n\n")
                file.write(f"#endif\n\n")

                file.write(f"#ifdef {instrction_type}_DECLARATIONS_GEN\n\n")
                for datatype in datatypes:   
                    for marker in markers:  
                        file.write(f"{marker}_{instrction_type}_{datatype}_DECS\n\n")
                file.write(f"#endif\n\n")
    
    def update_config_file(self, result):
        # file_path = "../../../include/mlir/Dialect/Rock/Tuning/QuickTuningPerfconfigs.inc"
        file_path = "out-test.inc"
        if not os.path.exists(file_path):
            self.init_inc_file(file_path)

        datatype_names_defs = {
            'f32' : f"const InitParamsAccel PopulateParams{self.get_instruction_type(self.arch, 'f32')}::initParameters{self.op.capitalize()}[PopulateParamsXDL::nInitParameters{self.op.capitalize()}]",
            'f16' : f"const InitParamsAccel PopulateParams{self.get_instruction_type(self.arch, 'f16')}::initParametersFp16{self.op.capitalize()}[PopulateParamsXDL::nInitParametersFp16{self.op.capitalize()}]",
            'i8'  : f"const InitParamsAccel PopulateParams{self.get_instruction_type(self.arch, 'i8')}::initParametersForward8Bit{self.op.capitalize()}[PopulateParamsXDL::nInitParametersForward8Bit{self.op.capitalize()}]"
        }

        for datatype, perfconfigs in result.items():
            lines = []
            datatype_name = datatype_names_defs.get(datatype)
            lines.append(f"{datatype_name} = {{")
            for idx, perfconfig in enumerate(perfconfigs):
                formated_perfconfig = self.parse_perfconfigs(perfconfig)
                if idx == len(perfconfigs) - 1:
                    lines.append(f"    {{{formated_perfconfig}}}")
                else: 
                    lines.append(f"    {{{formated_perfconfig}}},")
            lines.append("};")

            new_content = '\n'.join(lines)
            self.replace_section(file_path, f"// BEGIN_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DEFS", f"// END_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DEFS", new_content)

        datatype_names_decs = {
            'f32' : f"static const InitParamsAccel initParameters{self.op.capitalize()}[nInitParameters{self.op.capitalize()}]",
            'f16' : f"static const InitParamsAccel initParametersFp16{self.op.capitalize()}[nInitParametersFp16{self.op.capitalize()}]",
            'i8'  : f"static const InitParamsAccel initParametersForward8Bit{self.op.capitalize()}[nInitParametersForward8Bit{self.op.capitalize()}]"
        }
        datatype_n_decs = {
            'f32' : f"static constexpr size_t nInitParameters{self.op.capitalize()}",
            'f16' : f"static constexpr size_t nInitParametersFp16{self.op.capitalize()}",
            'i8'  : f"static constexpr size_t nInitParametersForward8Bit{self.op.capitalize()}"
        }

        for datatype, perfconfigs in result.items():
            lines = []
            datatype_name_dec = datatype_names_decs.get(datatype)
            datatype_n_dec = datatype_n_decs.get(datatype)
            lines.append(f"{datatype_n_dec} = {len(perfconfigs)};")
            lines.append(f"{datatype_name_dec};")

            new_content = '\n'.join(lines)
            self.replace_section(file_path, f"// BEGIN_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DECS", f"// END_{self.op.upper()}_{self.get_instruction_type(self.arch, datatype)}_{datatype}_DECS", new_content)

class PerfConfigsFinder():

    def __init__(self, pargs):
        self.th = pargs.th
        self.op = pargs.op
        self.input_file = pargs.input_file
        self.arch = pargs.arch
        self.df = pd.read_csv(self.input_file, sep='\t')
    
    def get_unique_perfconfigs_list(self, problems_to_perfconfigs):
        perfconfigs_set = set()
        for perfconfigs_lists in problems_to_perfconfigs.values():
                perfconfigs_set.update(perfconfigs_lists)
        return list(perfconfigs_set)
        
    def get_top_n_perfconfigs_per_problems(self, df, targetColumns):
        grouped = df.groupby(targetColumns)
        problem_df = {}
        for name, grouped_df in grouped:
            max_value = grouped_df['TFlops'].max()  
            threshold = max_value * 0.93
            problem_df[name] = grouped_df[grouped_df['TFlops'] >= threshold]['PerfConfig']
        return problem_df

    def create_matrix_A(self, ):

    def find(self):
        result = {}
        unique_data_types = self.df['DataType'].unique()

        targetColumns = []
        if self.op == "gemm":
            targetColumns = ['TransA', 'TransB', 'G', 'M', 'K', 'N']
        else:
            targetColumns = ['Direction','InputLayout', 'N', 'C', 'H', 'W', 'K', 'Y', 'X', 'DilationH', 'DilationW', 'StrideH', 'StrideW', 'PaddingH', 'PaddingW']

        for data_type in unique_data_types:
            df_typed = self.df[self.df['DataType'] == data_type]
            problems_to_perfconfigs = self.get_top_n_perfconfigs_per_problems(df_typed, targetColumns)

            problems = problems_to_perfconfigs.keys()
            perfconfigs = self.get_unique_perfconfigs_list(problems_to_perfconfigs)

            n = len(problems)
            m = len(perfconfigs)
            problem_to_index = {problem: idx for idx, problem in enumerate(problems)}
            perfconfig_to_index = {perfconfig: idx for idx, perfconfig in enumerate(perfconfigs)}

            A = np.zeros((n, m), dtype=int)
            for problem, perfconfig_list in problems_to_perfconfigs.items():
                i = problem_to_index[problem]
                for perfconfig in perfconfig_list:
                    j = perfconfig_to_index[perfconfig]
                    A[i][j] = 1

            prob = pulp.LpProblem("SetCoverProblems", pulp.LpMinimize)
            x = pulp.LpVariable.dicts("x", range(m), cat='Binary')
            prob += pulp.lpSum([x[j]] for j in range(m))
            for i in range(n):
                prob += pulp.lpSum([A[i][j] * x[j] for j in range(m)]) >= 1, f"Cover_problem_{i}"

            prob.solve(pulp.PULP_CBC_CMD(msg=0))

            selected_configs = [perfconfigs[j] for j in range(m) if x[j].varValue == 1]

            result[data_type] = selected_configs
        return result

def main(args=None):

    if args is None:
        args = sys.argv[1:]

    parser = argparse.ArgumentParser(prog='quickTunerGen.py')

    parser.add_argument('--input-file',
                            required=True,
                            type=str)

    parser.add_argument('--op',
                             required=True,
                             type=str,
                             choices=["gemm", "conv"])

    parser.add_argument("--th",
                            required=False,
                            type=float,
                            default=0.93)

    parser.add_argument("--arch",
                         required=True,
                         type=str)
    
    parser.add_argument("--update",
                         required=False,
                         default=False,
                         action='store_true')

    pargs = parser.parse_args()

    finder = PerfConfigsFinder(pargs)
    result = finder.find()

    file_writer = FileWriter(pargs) 
    file_writer.update_config_file(result)

if __name__ == '__main__':
    main(sys.argv[1:])